module Main where

import Control.Monad (forM)
import Data.List
import qualified Data.List.Utils as LU
import Data.Time (getCurrentTime, formatTime, defaultTimeLocale)
import qualified Debug.Trace as DT
import System.Directory (doesDirectoryExist, getCurrentDirectory
                        , getDirectoryContents, createDirectoryIfMissing)
import System.Environment (getArgs)
import System.FilePath ((</>), takeExtension, dropFileName
                        , splitPath, joinPath, replaceExtension)


findFilesFromPath :: FilePath -> IO [FilePath]
findFilesFromPath fromPath = do
  ctxNames <- getDirectoryContents fromPath
  let validNames = filter (`notElem` [".", "..", "readme.md", "README.md"]) ctxNames
  paths <- forM validNames $ \name -> do
    let path = fromPath </> name
    isDirectory <- doesDirectoryExist path
    if isDirectory
      then findFilesFromPath path
      else return [path]
  return (concat paths)


filterFiles :: (FilePath -> Bool) -> FilePath -> IO [FilePath]
filterFiles predicate fromPath = do
  names <- findFilesFromPath fromPath
  return (filter predicate names)


parseMarkdownFile :: String -> String -> String
parseMarkdownFile codeLang content =
  let stringResult = parseEmacsLisp content codeLang
      cleanItems = map (\xs -> LU.replace "\n\n\n" "\n" xs) stringResult
  in (intercalate "\n\n" $ cleanItems)


parseEmacsLisp :: String -> String -> [String]
parseEmacsLisp [] _ = []
parseEmacsLisp str codeLang = 
  let tofinde = "```" ++ codeLang ++ "\n"
      cleanPrefix = LU.dropWhileList (\xs -> (take 14 xs) /= tofinde) str
      dropPrefix = drop 14 cleanPrefix
      getCode = LU.takeWhileList (\xs -> (take 4 xs) /= "\n```") dropPrefix
  in if null dropPrefix 
    then [getCode] ++ parseEmacsLisp [] codeLang
    else [getCode] ++ parseEmacsLisp dropPrefix codeLang


mapFileExt :: String -> String
mapFileExt ".md" = ".el"
mapFileExt _     = ".el"


buildEmacsLispSourseFile :: String -> String -> String -> FilePath -> String -> String -> IO FilePath
buildEmacsLispSourseFile fromPath toPath fpath content fileExt codeLang = do
  let fromPathList = splitPath fromPath
      fpathList = splitPath fpath
      diff = dropWhile (`elem` fromPathList) fpathList
      newext = mapFileExt fileExt
      pbase = replaceExtension (joinPath diff) newext
      path = toPath </> pbase
      emacsCode = parseMarkdownFile codeLang content
  if null emacsCode
    then return ""
    else do now <- getCurrentTime
            let today = formatTime defaultTimeLocale "%d.%m.%y" now
                footerline = ";; End file " ++ today ++ " Generated by md2el @ 2017 \n"
                ctx = emacsCode ++ footerline
            createDirectoryIfMissing True $ dropFileName path
            writeFile path ctx
            putStrLn path
            return path


makeDirs :: String -> [String] -> IO ()
makeDirs toPath emacsUserDirsNames = 
  putStrLn "Created dirs structure for emacs-stallman: " >>
  createBase >> 
  createEmacsLisp >> 
  createUserDirs
  where 
    createDir = (\d -> DT.traceShow (toPath </> d) $ createDirectoryIfMissing True (toPath </> d))
    createBase = mapM_ createDir ["site-lisp", "emacs-lisp"]
    emacsLisp = map ("emacs-lisp" </>) ["major_mode", "minor_mode", "system", "themes", "vendor"]
    createEmacsLisp = mapM_ createDir emacsLisp
    resources = ["auto-save", "auto-save-list", "backups", "ido", "recentf", "savehist", "smex"]
    userDirs = [toPath </> "resources" </> user </> res | user <- emacsUserDirsNames, res <- resources]
    createUserDirs = mapM_ createDir userDirs


processFiles :: FilePath -> FilePath -> String -> String -> IO ()
processFiles fromPath toPath fileExt codeLang = do
  markdownFiles <- case fileExt of 
    ".md" -> filterFiles (\p -> takeExtension p == ".md") fromPath
    _ -> return ([])
  putStrLn "Find markdown files: " >> mapM_ putStrLn markdownFiles
  putStrLn "Created new emacs lisp files: "
  _ <- forM markdownFiles $ \fpath -> do
    content <- readFile fpath
    buildEmacsLispSourseFile fromPath toPath fpath content fileExt codeLang
  return ()


helpText :: String -> IO ()
helpText "help"                   = putStrLn "--help - program to generate emacs lisp code from markdown files, *.md -> *.el"
helpText "from-path"              = putStrLn "--from-path /path/ - path to search file in deep, by default - current dir"
helpText "to-path"                = putStrLn "--to-path /path/ - destinations"
helpText "file-ext"               = putStrLn "--file-ext - search files with extentions, by default - `.md`"
helpText "code-lang"              = putStrLn "--code-lang, by default - emacs lisp"
helpText "emacs-users-dirs-names" = putStrLn "--emacs-users-dirs-name arg1 arg2 argn - create dirs structure for emacs-stallman"
helpText "args-error"             = putStrLn "Wrong arguments, pass two args: --from-path --to-path --file-ext --code-lang"
helpText _                        = putStrLn "Wrong arguments"


main :: IO ()
main = do
  args <- getArgs
  thisDir <- getCurrentDirectory
  case args of
    ("--help":_) -> helpText "help" 
    ("--to-path":toPath:"--emacs-users-dirs-names":emacsUserDirsNames) -> makeDirs toPath emacsUserDirsNames
    ("--from-path":fromPath:"--to-path":toPath:"--file-ext":fileExt:"--code-lang":(codeLang:_)) -> processFiles fromPath toPath fileExt codeLang
    ("--from-path":fromPath:"--to-path":(toPath:_)) -> processFiles fromPath toPath ".md" "emacs lisp"
    [] -> processFiles thisDir (thisDir </> "dist" </> ".emacs.d") ".md" "emacs lisp"
    _ -> helpText "args-error"
